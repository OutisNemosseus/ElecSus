---
title: fs_hfs.py - Fine and Hyperfine Structure
sidebar_label: fs_hfs.py
sidebar_position: 13
---

# fs_hfs.py - Fine and Hyperfine Structure Matrices

<div style={{display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: '24px'}}>
  <a href="/libs/fs_hfs.py" download="fs_hfs.py"
    style={{padding: '10px 20px', backgroundColor: '#10b981', color: 'white', borderRadius: '6px', textDecoration: 'none', fontWeight: 'bold'}}>
    Download .py
  </a>
</div>

<div style={{display: 'flex', gap: '24px', marginBottom: '24px', flexWrap: 'wrap'}}>
  <div style={{padding: '12px 16px', backgroundColor: '#f3f4f6', borderRadius: '8px'}}>
    <div style={{fontSize: '24px', fontWeight: 'bold', color: '#3776ab'}}>134</div>
    <div style={{fontSize: '12px', color: '#6b7280'}}>Lines of Code</div>
  </div>
  <div style={{padding: '12px 16px', backgroundColor: '#f3f4f6', borderRadius: '8px'}}>
    <div style={{fontSize: '24px', fontWeight: 'bold', color: '#3776ab'}}>3</div>
    <div style={{fontSize: '12px', color: '#6b7280'}}>Functions</div>
  </div>
</div>

## Description

Calculates the energy splitting matrices for fine and hyperfine structure. Provides functions to calculate the three matrices needed from equations (6), (7) and (8) in the ElecSus manual.

Called by `EigenSystem.py`.

## Dependencies

```python
from numpy import identity, dot
from scipy.linalg import kron
from ang_mom import jx, jy, jz
```

## Functions

### `Hfs(L, S, I)`

Provides the L·S matrix (fine structure splitting).

**Arguments:**
- `L` - Orbital angular momentum quantum number
- `S` - Electron spin
- `I` - Nuclear spin

**Returns:**
- Fine structure Hamiltonian matrix H_fs = (1/2)(J² - L² - S²)

**Physics:**
The fine structure arises from the spin-orbit interaction:
```
H_fs = ζ(r) L·S = (ζ/2)[J² - L² - S²]
```
where J = L + S.

### `Hhfs(L, S, I)`

Provides the I·J matrix (hyperfine structure interaction).

**Arguments:**
- `L` - Orbital angular momentum quantum number
- `S` - Electron spin
- `I` - Nuclear spin

**Returns:**
- Hyperfine structure Hamiltonian matrix H_hfs = (1/2)(F² - I² - J²)

**Physics:**
The magnetic dipole hyperfine interaction is:
```
H_hfs = A_hfs I·J = (A_hfs/2)[F² - I² - J²]
```
where F = I + J.

### `Bbhfs(L, S, I)`

Calculates the electric quadrupole matrix.

**Arguments:**
- `L` - Orbital angular momentum quantum number
- `S` - Electron spin
- `I` - Nuclear spin

**Returns:**
- Electric quadrupole Hamiltonian matrix

**Physics:**
For nuclei with I ≥ 1, there is a quadrupole contribution:
```
H_Q = B_hfs [3(I·J)² + (3/2)(I·J) - I(I+1)J(J+1)] / [2I(2I-1)J(2J-1)]
```

## Source Code

```python showLineNumbers
from numpy import identity, dot
from scipy.linalg import kron
from ang_mom import jx, jy, jz

def Hfs(L, S, I):
    """Provides the L dot S matrix (fine structure)"""
    gS = int(2*S + 1)
    gL = int(2*L + 1)
    gI = int(2*I + 1)

    # Construct J = L + S operators
    Jx = kron(jx(L), identity(gS)) + kron(identity(gL), jx(S))
    Jy = kron(jy(L), identity(gS)) + kron(identity(gL), jy(S))
    Jz = kron(jz(L), identity(gS)) + kron(identity(gL), jz(S))
    J2 = dot(Jx, Jx) + dot(Jy, Jy) + dot(Jz, Jz)

    gF = gL * gS * gI
    Fi = identity(gF)
    # H_fs = (1/2)(J² - L(L+1) - S(S+1))
    Hfs = 0.5 * (kron(J2, identity(gI)) - L*(L+1)*Fi - S*(S+1)*Fi)
    return Hfs

def Hhfs(L, S, I):
    """Provides the I dot J matrix (hyperfine structure)"""
    # Similar construction using F = I + J
    # Returns (1/2)(F² - I² - J²)
    pass

def Bbhfs(L, S, I):
    """Electric quadrupole matrix"""
    # Quadrupole contribution for I >= 1
    pass
```

## Usage Example

```python
import numpy as np
from fs_hfs import Hfs, Hhfs, Bbhfs

# Rb-87 D1 excited state: L=1, S=1/2, I=3/2
L, S, I = 1, 0.5, 1.5

# Fine structure matrix
H_fine = Hfs(L, S, I)
print(f"Fine structure matrix dimension: {H_fine.shape}")

# Hyperfine structure matrix
H_hyp = Hhfs(L, S, I)
print(f"Hyperfine matrix dimension: {H_hyp.shape}")

# Full Hamiltonian (schematic)
A_hfs = 406.147  # MHz (Rb-87 D1)
Delta_fs = 7.123e6  # MHz
H_total = Delta_fs * H_fine + A_hfs * H_hyp

# Eigenvalues give the energy levels
energies = np.linalg.eigvalsh(H_total)
print("Energy levels (MHz):", np.sort(energies))
```

## Energy Level Structure

### Fine Structure (L·S coupling)

For D-lines:
- D1: ²S₁/₂ → ²P₁/₂ (L=0 → L=1, J=1/2)
- D2: ²S₁/₂ → ²P₃/₂ (L=0 → L=1, J=3/2)

### Hyperfine Structure (I·J coupling)

For the excited state, F = I + J gives:
- D1 (J=1/2): F = I ± 1/2
- D2 (J=3/2): F = I - 3/2, I - 1/2, I + 1/2, I + 3/2

---

[Back to Library Reference](./)
